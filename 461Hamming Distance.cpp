# Details-explanation-of-Leetcode-in-C
# https://leetcode.com/problems/hamming-distance/


/********************************************************************************** 
* 
* 有两个很关键的地方
*      1 有异或（^）去衡量 位 的不同
*      2  n&(n-1)作用：将n的二进制表示中的最低位为1的改为0，先看一个简单的例子：
*          n = 10100(二进制），则(n-1) = 10011 ==》n&(n-1) = 10000
       (n-1) = 10011
*  ==》n&(n-1) = 10000
*
*         可以看到原本最低位为1的那位变为0。（&表示按位与）
* 
           
**********************************************************************************/




class Solution {
public:
    int hammingDistance(int x, int y) {
        int dist = 0, n = x ^ y;   // 
        while (n) {
            ++dist;
            n &= n - 1;
        }
        return dist;
    }
};
/**********************************************************************************
*扩展 弄明白了n&(n-1)的作用，那它有哪些应用？
------------------------------------------------------------------------------------------------------
1、 判断一个数是否是2的方幂
n > 0 && ((n & (n - 1)) == 0 )
解释((n & (n-1)) == 0)：
如果A&B==0，表示A与B的二进制形式没有在同一个位置都为1的时候。
那么本题到底啥意思？？
不妨先看下n-1是什么意思。
   令:n=1101011000(二进制,十进制也一样)，则
    n-1=1101010111。
n&(n-1)=1101010000
由此可以得出，n和n-1的低位不一样，直到有个转折点，就是借位的那个点，从这个点开始的高位，n和n-1都一样，如果高位一样这就造成一个问题，就是n和n-1在相同的位上可能会有同一个1，从而使((n & (n-1)) != 0),如果想要
((n & (n-1)) == 0)，则高位必须全为0，这样就没有相同的1。
所以n是2的幂或0
2. 求某一个数的二进制表示中1的个数
while (n >0 ) {
      count ++;
      n &= (n-1);
}
3. 计算N!的质因数2的个数。
容易得出N!质因数2的个数 = [N / 2] + [N / 4] + [N / 8] + ....
下面通过一个简单的例子来推导一下过程：N = 10101(二进制表示）
现在我们跟踪最高位的1，不考虑其他位假定为0，
则在
[N / 2]    01000
[N / 4]    00100
[N / 8]    00010
[N / 8]    00001
则所有相加等于01111 = 10000 - 1
由此推及其他位可得：(10101)!的质因数2的个数为10000 - 1 + 00100 - 1 + 00001 - 1 = 10101 - 3(二进制表示中1的个数)

推及一般N!的质因数2的个数为N-(N二进制表示中1的个数)
